<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Geek and Latin</title>
    <link>/post/</link>
    <description>Recent content in Posts on Geek and Latin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© sudarshan-reddy@github.io</copyright>
    <lastBuildDate>Mon, 07 Jan 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why types are elegant</title>
      <link>/post/static-typing-is-beautiful/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/static-typing-is-beautiful/</guid>
      <description>I&amp;rsquo;ve been working with a Go(for work) and Rust(for fun) lately. I got pulled into the two languages for different reasons (easy concurrency and memory safety respectively) and ended up staying for a totally different reason altogether. Their type systems.
Composition instead of inheritance feels elegant, right and very readable. I&amp;rsquo;m going to talk about something that happened today when I was very thankful for composition and typing itself.
A colleague and I ran into a problem that quickly devolved into an argument and as it is with professional software engineers, wanton namecalling.</description>
    </item>
    
    <item>
      <title>Training a simple gender classifier with Python and Predicting with Go</title>
      <link>/post/keras-to-go/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/keras-to-go/</guid>
      <description>Ever since Tensorflow released Bindings for Go, I&amp;rsquo;ve been itching to give it a go. The ease of deployability with Go and microservice friendliness and even simple http performance improvements make it really handly to build a working prediction application with Go.
The immediate and apparent downside for anyone who&amp;rsquo;s tried to train a model is how unintuitive scoping is with Tensorflow for Go.Python&amp;rsquo;s a lot easier to train models with for a newcomer because of a lot of things:</description>
    </item>
    
    <item>
      <title>Env variables</title>
      <link>/post/env-variables/</link>
      <pubDate>Mon, 04 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/env-variables/</guid>
      <description>Ever wake up on the symmetrical side of the bed? Like at the middle? Yep. That�s when you decide that you are never going to (ever) code in constants in your application. So how do you get them? Configuration files? JSONs? Yamls? Environment variables are more elegant and easier with a docker-compose no?
12 factor apps are what cool kids are doing these days (read three years ago). And it makes sense that you put your configurable variables into the environment and do a getenv.</description>
    </item>
    
  </channel>
</rss>